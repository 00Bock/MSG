<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bootstrap-Test</title>
	
	<script src="http://d3js.org/d3.v3.min.js"></script>
	
	<!-- App -->
    <link href="css/app.css" rel="stylesheet">
	
    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
	
	<!-- Mapbox -->
	<script src='https://api.tiles.mapbox.com/mapbox.js/v1.6.1/mapbox.js'></script>
	<link href='https://api.tiles.mapbox.com/mapbox.js/v1.6.1/mapbox.css' rel='stylesheet' />

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
	<!-- Daten einladen-->
	<script src='data/msgPoints.js'></script>
	<script src='data/msgLines.js'></script>
	<script src="data/line.js">//do we need this? -> yes</script>
	<script src="data/line1.js"></script>
	<script src="data/line2.js"></script>
	<script src="data/line3.js"></script>
	<script src="data/line4.js"></script>
	<script src="data/line5.js"></script>
	<script src="data/line6.js"></script>
	<script src="data/line7.js"></script>
	<script src="data/line8.js"></script>
	<script src="data/line9.js"></script>
	<script src="data/line10.js"></script>
	<script src='data/data_producer.js'></script>
  
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="js/bootstrap.min.js"></script>
	
	<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
	  <div class="container-fluid">
		<!-- Brand and toggle get grouped for better mobile display -->
		<div class="navbar-header">
		  <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
			<span class="sr-only">Toggle navigation</span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		  </button>
		  <a class="navbar-brand" href="index_boot.html">SmartEnergyMap</a>
		</div>

		<!-- Collect the nav links, forms, and other content for toggling -->
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
		  <ul class="nav navbar-nav">
			<li class="active"><a href="#">Map</a></li>
			<li><a href="#">About</a></li>
			<li><img id="navLogo" src="img/logo2.png"></li>
		  </ul>
		</div><!-- /.navbar-collapse -->
	  </div><!-- /.container-fluid -->
	</nav>
	<!-- The Map -->
	<div id="map"></div>
	<div id='map1'></div>
	<div id='map2'></div>
	<!-- Animationsknopf hinzufügen
	<div>
		<img id="animationButton" src="img/animationButton.png">
		<input 	name="animationButton"
					type="image"
					value="Start Animation"	
					src="img/animationButton.png
			/>
	</div>
	<!-- Add a div for the button onclick="startAnimation()" -->
		<div id="animationButton">
			<input 	name="animationButton"
					type="button"
					value="Start Animation"	
					onclick="startAnimation()"
			/>
		</div>
	<!-- Animationsknopf hinzufügen-->
	<!--<div><img id="logo" src="img/logo2.png"></div>-->
	<div id="titleLocation">Location-View</div>
	<div id="titleEnergy">Energy-View</div>
	<div id="currentTime"></div>
	<div id="locationLegend"><img id="locationLegend" src="img/LegendInnoZLocation.png"></div>
		<script>
		
		/*
		//### Inizialisierung der Karte ###
		var map = L.mapbox.map('map')
					.setView([52.481707, 13.356576], 18);
		//### Hintergrundkarten definieren ###
		var coolMap = L.mapbox.tileLayer('examples.map-51f69fea').addTo(map);
		*/
		// Instead of our usual one map, we will create two in this example to make
		// things interesting.
		var map1 = L.mapbox.map('map1', 'examples.map-b70jh5xu', {opacity: 0.5})
			.setView([52.481707,13.356576], 19);
		var map2 = L.mapbox.map('map2', 'examples.map-cnkhv76j', { zoomControl:false })
			.setView([52.481707,13.356576], 18);

		// when either map finishes moving, trigger an update on the other one.
		map1.on('moveend', follow).on('zoomend', follow);
		map2.on('moveend', follow).on('zoomend', follow);

		// quiet is a cheap and dirty way of avoiding a problem in which one map
		// syncing to another leads to the other map syncing to it, and so on
		// ad infinitum. this says that while we are calling sync, do not try to 
		// loop again and sync other maps
		var quiet = false;
		function follow(e) {
			if (quiet) return;
			quiet = true;
			if (e.target === map1) sync(map2, e);
			if (e.target === map2) sync(map1, e);
			quiet = false;
		}

		// sync simply steals the settings from the moved map (e.target)
		// and applies them to the other map.
		function sync(map, e) {
			map.setView(e.target.getCenter(), e.target.getZoom(), {
				animate: false,
				reset: true
			});
		}
		
		//Maßstab hinzufügen
		L.control.scale().addTo(map1);
		
		//### Punkte und Linien einbinden ###
		var msgPoints = msgPoints; //schreibt js-Inhalt in Variable

		//Punkte hinzufügen --> alte Punkte
		//map.featureLayer.setGeoJSON(msgPoints); // add points with style

		//Popup hinzufügen --> vertragt sich nicht mit dem style und überlagert sich daher mit den bereits eingefügten Punkten
		/*
		var myLayer = L.geoJson(msgPoints, {
			// style: function (feature) {
			//     return feature.properties.style;
			// },
			 onEachFeature: function (feature, layer) {
				 layer.bindPopup(feature.properties.type + '</br>' + 
									'Energiewert: ' + feature.properties.value);
			 }
		 });

		 
		//myLayer.addData(msgPoints);
		myLayer.addTo(map);
		*/
		
		//### hinzufügen von individuellen Markern ###
		// dafür sollte eine Funktion erstellt werden!
			//große Symbole
			var LeafIcon = L.Icon.extend({
				options: {
					//shadowUrl: '../docs/images/leaf-shadow.png',
					iconSize:     [80, 80],
					//shadowSize:   [50, 64],
					//iconAnchor:   [22, 94],
					//shadowAnchor: [4, 62],
					popupAnchor:  [0, -10]
				}
			});
			//kleine Symbole
			var LeafIconLittle = L.Icon.extend({
				options: {
					//shadowUrl: '../docs/images/leaf-shadow.png',
					iconSize:     [30, 28],
					//shadowSize:   [50, 64],
					//iconAnchor:   [22, 94],
					//shadowAnchor: [4, 62],
					popupAnchor:  [0, -10]
				}
			});

			var batterieIcon = new LeafIcon({iconUrl: 'img/battery_ebattery_w.png'}),
				windIcon = new LeafIcon({iconUrl: 'img/producer_wind_w.png'}),
				chargingIcon = new LeafIcon({iconUrl: 'img/battery_ecar_w.png'}),
				photoIcon = new LeafIcon({iconUrl: 'img/producer_solar_w.png'}),
				brainIcon = new LeafIcon({iconUrl: 'img/minigrid_minigrid_w.png'}),
				netIcon = new LeafIconLittle({iconUrl: 'img/netconnectionT.png'});
			
			//Add marker to Map1
			L.marker([52.48243899971542, 13.35747111893229], {icon: batterieIcon}).addTo(map1);
			L.marker([52.480688658255012 , 13.354568528677662], {icon: windIcon}).addTo(map1);
			L.marker([52.480911923161734, 13.355110029627905], {icon: windIcon}).addTo(map1);
			L.marker([52.481457 , 13.355791], {icon: windIcon}).addTo(map1);
			L.marker([52.48159684369503, 13.355837930668985], {icon: windIcon}).addTo(map1);
			L.marker([52.481227, 13.356873], {icon: windIcon}).addTo(map1);
			L.marker([52.481662, 13.357115], {icon: windIcon}).addTo(map1);
			L.marker([52.482262, 13.357565], {icon: photoIcon}).addTo(map1);
			L.marker([52.482455631243511, 13.357434101623429], {icon: photoIcon}).addTo(map1);
			L.marker([52.481356, 13.355660], {icon: photoIcon}).addTo(map1);
			L.marker([52.480605, 13.354743], {icon: netIcon}).addTo(map1);
			L.marker([52.482146, 13.357430], {icon: brainIcon}).addTo(map1);
			
			//Add marker to Map2 with popup
			L.marker([52.48243899971542, 13.35747111893229], {icon: batterieIcon}).bindPopup("<h4>I am a battery.</h4> <p> Capacity: 80% </p>").addTo(map2);
			L.marker([52.480688658255012 , 13.354568528677662], {icon: windIcon}).bindPopup("I am a wind wheel.").addTo(map2);
			L.marker([52.480911923161734, 13.355110029627905], {icon: windIcon}).bindPopup("I am a wind wheel.").addTo(map2);
			L.marker([52.481457 , 13.355791], {icon: windIcon}).bindPopup("I am a wind wheel.").addTo(map2);
			L.marker([52.48159684369503, 13.355837930668985], {icon: windIcon}).bindPopup("I am a wind wheel.").addTo(map2);
			L.marker([52.481227, 13.356873], {icon: windIcon}).bindPopup("I am a wind wheel.").addTo(map2);
			L.marker([52.481662, 13.357115], {icon: windIcon}).bindPopup("I am a wind wheel.").addTo(map2);
			L.marker([52.482262, 13.357565], {icon: photoIcon}).bindPopup("<img src='img/popup_small.png'/>").addTo(map2);
			L.marker([52.482455631243511, 13.357434101623429], {icon: photoIcon}).bindPopup("I am a solar mover.").addTo(map2);
			L.marker([52.481356, 13.355660], {icon: photoIcon}).bindPopup("I am a solar panel.").addTo(map2);
			L.marker([52.480605, 13.354743], {icon: netIcon}).bindPopup("Connection to the electric grid.").addTo(map2);
			L.marker([52.482146, 13.357430], {icon: brainIcon}).bindPopup("I am the brain of the grid.").addTo(map2);
		
		
		//Add Energy-Circles
		//Code-Example: http://stackoverflow.com/questions/22467177/draw-a-circle-of-constant-size-for-all-zoom-levels-leaflet-js
		var windValue1 = 0.5;
		var windValue2 = 1;
		/*
		//Berechnung der Kreisgröße anhand der Stevenschen psychophisischen Potenzfunktion
		var circleRadius1 = (Math.pow(windValue1, (5/7)))/(Math.sqrt(2*Math.PI));
		var circleRadius2 = (Math.pow(windValue2, (5/7)))/(Math.sqrt(2*Math.PI));
		
		var circleRadius1 = windValue1 * 20;
		var circleRadius2 = windValue2 * 20;
		var coordinates1 = [52.481227, 13.354743];
		var coordinates2 = [52.48166, 13.357115];
		drawCircle(circleRadius1, coordinates1);
		drawCircle(circleRadius2, coordinates2);
		
		function drawCircle(circleRadius, coordinates) {
		var circleStyle = {
			fillColor: '#00BFFF',
			fillOpacity: 0.5
		};
		var circle = L.circle(coordinates, circleRadius, circleStyle).addTo(map2);

		var myZoom = {
		  start:  map2.getZoom(),
		  end: map2.getZoom()
		};

		map2.on('zoomstart', function(e) {
		   myZoom.start = map2.getZoom();
		});

		map2.on('zoomend', function(e) {
			myZoom.end = map2.getZoom();
			var diff = myZoom.start - myZoom.end;
			if (diff > 0) {
				circle.setRadius(circle.getRadius() * 2);
			} else if (diff < 0) {
				circle.setRadius(circle.getRadius() / 2);
			}
		});
		}
		*/
		//### add Lines with Leaflet-Funktion
		//Linien befinden sich später in der D3-Ebene
		var lines = msgLines;
		
		var myStyle = {
			"color": "#0099CC",
			"weight": 3,
			"opacity": 0.65
		};
		L.geoJson(lines, {style: myStyle}).addTo(map1);
		
		/*
		var animation = document.getElementById('animationButton');
		animation.onclick = function startAnimation() {
			alert("Diese Funktion wird gerade implementiert. Die Energieströme werden bald fließen!");
		};
		*/
		
		//initialize the variable myPath
		var myPath;
		//initialize the animationFunction und access the button over the DOM
		//example --> http://jsfiddle.net/pFYUM/1/
		var animationFunction = document.getElementById('animationButton');
			
	
		//### add a d3 svg/g-element to the map 
		// Initialize the SVG layer
		map2._initPathRoot()    
		//pick up the SVG from the map object
		var svg = d3.select("#map2").select("svg");
		
				
		//### add lines ###
		// Add a second SVG element to Leaflet’s overlay pane to make sure that they fit together
		var svg2 = d3.select(map2.getPanes().overlayPane).append("svg2"),
			// the g element make sure that the D3- and Leaflet-Layer has the same point of reference
			g2 = svg2.append("g2").attr("class", "leaflet-zoom-hide");
			
		var drawCounter = 0;	
		var drawFunction;
			
			drawFunction(line1);
			drawFunction(line2);
			drawFunction(line3);
			drawFunction(line4);
			drawFunction(line5);
			drawFunction(line6);
			drawFunction(line7);
			drawFunction(line8);
			drawFunction(line9);
			drawFunction(line10);
		
		
		function drawFunction (line) {	
			g = svg.append("g")
				.attr("class", "route" + drawCounter)
				.attr("id", drawCounter);
		
			//transform corectly the latitude/longitude coordinates to screen coordinates
			var transform = d3.geo.transform({point: projectPoint}),
			path = d3.geo.path().projection(transform);
				
			// create path elements for each of the features and append it to our g group
			var featureLength = msgLines.features.length;
			
			//load the json-data		
			d3_features = g.selectAll("path")
				.data(line.features)
				.enter().append("path").attr("d", path)
				.attr('id', line.features[0].properties.id)
				.style("stroke", "white")
				.style("fill", "none");
			
			// make sure that the d3 element changes when we zoom or pan 
			map2.on("viewreset", reset);
				
			reset();
				
			// fit the SVG element to leaflet's map layer -> reset the d3-layer when the extant changes
			function reset() {
				//take the current coordinates of the topLeft and buttomRight corners
				bounds = path.bounds(msgLines);
				var topLeft = bounds[0],
					bottomRight = bounds[1];
					// apply the coordniates to the svg
					svg2.attr("width", bottomRight[0] - topLeft[0])
						.attr("height", bottomRight[1] - topLeft[1])
						.style("left", topLeft[0] + "px")
						.style("top", topLeft[1] + "px");
					g2.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");

		// initialize the path data
			d3_features.attr("d", path)
						.style("fill-opacity", 0.7)
						.attr('fill','blue')
						.attr('id', drawCounter);
			}
		
		// take the latitude and longitudes and transform them into screen coordinates
			function projectPoint(x, y) {
				var point = map2.latLngToLayerPoint(new L.LatLng(y, x));
				this.stream.point(point.x, point.y);
			}
		//set the counter one in plus
		drawCounter++;
		}	
	
	// ### animation
	// animate the path by click --> use the animation function
	animationFunction.onclick = startAnimation;
			
	
	// animate the path --> this is the function
	// original code from here: http://jsfiddle.net/5m35J/6/
	function startAnimation() {
		
		// declare some variables
		var vis, xy, duration, offset, origin_x, origin_y, len, circle, circle0, circle1, circle2, circle3;

		var lineNumber = 0;
		var v = 0.02;

		//### Runde 1
		
		var group = svg.append("svg:g");
		
		//take the path from the geojson
		var targetPath = d3.selectAll('.route0')[0][0];
		var pathNode = d3.select(targetPath).selectAll('path').node();
		var pathLength = pathNode.getTotalLength();	
		//console.log(pathLength);
		duration = pathLength/v;
		
		//take the energy value from the data
		var energyValue = data_producer[1].WEA_Haus1;
		//console.log(energyValue);
		var energyMag = energyValue;
		
		if (energyMag > 0 && energyMag <= 0.3) {
			//one circle
			//append the circle to the first vertex of the geojson
			circle = group.append("circle")
				.attr({
				r: 5,
				fill: '#00BFFF',
				transform: function () {
					var p = pathNode.getPointAtLength(0)
					return "translate(" + [p.x, p.y] + ")";
				},
				id: lineNumber
			});

			circle.transition()
				.duration(duration)
					.delay(750)
				.ease("linear")
				.attrTween("transform", function (d, i) {
				return function (t) {
					var p = pathNode.getPointAtLength(pathLength*t);
					return "translate(" + [p.x, p.y] + ")";
				}
			});
		} else if (energyMag > 0.3 && energyMag <= 0.6) {
			//2 circles
			circle = group.append("circle")
				.attr({
				r: 5,
				fill: '#00BFFF',
				transform: function () {
					var p = pathNode.getPointAtLength(0)
					return "translate(" + [p.x, p.y] + ")";
				}
			});
			circle2 = group.append("circle")
				.attr({
				r: 5,
				fill: '#00BFFF',
				transform: function () {
					var p = pathNode.getPointAtLength(0)
					return "translate(" + [p.x, p.y] + ")";
				}
			});
			
			// move the circle along the path
			circle.transition()
				.duration(duration)
					.delay(750)
				.ease("linear")
				.attrTween("transform", function (d, i) {
				return function (t) {
					var p = pathNode.getPointAtLength(pathLength*t);
					return "translate(" + [p.x, p.y] + ")";
				}
			});
			circle2.transition()
				.duration(duration)
					.delay(1250)
				.ease("linear")
				.attrTween("transform", function (d, i) {
				return function (t) {
					var p = pathNode.getPointAtLength(pathLength*t);
					return "translate(" + [p.x, p.y] + ")";
				}
			});
		} else {
			//3 circles
			circle = group.append("circle")
				.attr({
				r: 5,
				fill: '#00BFFF',
				transform: function () {
					var p = pathNode.getPointAtLength(0)
					return "translate(" + [p.x, p.y] + ")";
				}
			});
			circle2 = group.append("circle")
				.attr({
				r: 5,
				fill: '#00BFFF',
				transform: function () {
					var p = pathNode.getPointAtLength(0)
					return "translate(" + [p.x, p.y] + ")";
				}
			});
			circle3 = group.append("circle")
				.attr({
				r: 5,
				fill: '#00BFFF',
				transform: function () {
					var p = pathNode.getPointAtLength(0)
					return "translate(" + [p.x, p.y] + ")";
				}
			});

			// move the circle along the path
			circle.transition()
				.duration(duration)
					.delay(750)
				.ease("linear")
				.attrTween("transform", function (d, i) {
				return function (t) {
					var p = pathNode.getPointAtLength(pathLength*t);
					return "translate(" + [p.x, p.y] + ")";
				}
			});
			circle2.transition()
				.duration(duration)
					.delay(1250)
				.ease("linear")
				.attrTween("transform", function (d, i) {
				return function (t) {
					var p = pathNode.getPointAtLength(pathLength*t);
					return "translate(" + [p.x, p.y] + ")";
				}
			});
			
			circle3.transition()
				.duration(duration)
					.delay(1750)
				.ease("linear")
				.attrTween("transform", function (d, i) {
				return function (t) {
					var p = pathNode.getPointAtLength(pathLength*t);
					return "translate(" + [p.x, p.y] + ")";
				}
			});
		};
		
		
		//### Runde 2
		var group2 = svg.append("svg:g");
		
		//take the path from the geojson
		var targetPath2 = d3.selectAll('.route1')[0][0];
		var pathNode2 = d3.select(targetPath2).selectAll('path').node();
		var pathLength2 = pathNode2.getTotalLength();
		
		//append the circle to the first vertex of the geojson
		circle = group2.append("circle")
			.attr({
			r: 5,
			fill: '#00BFFF',
			transform: function () {
				var p = pathNode2.getPointAtLength(0)
				return "translate(" + [p.x, p.y] + ")";
			},
			id: lineNumber
		});
		

		duration = pathLength2/v;
		//var theCircle = "circle" + i;
		circle.transition()
			.duration(duration)
				.delay(750)
			.ease("linear")
			.attrTween("transform", function (d, i) {
			return function (t) {
				var p = pathNode2.getPointAtLength(pathLength2*t);
				return "translate(" + [p.x, p.y] + ")";
			}
		});

		//### Runde 3
		var group3 = svg.append("svg:g");
		
		//take the path from the geojson
		var targetPath3 = d3.selectAll('.route2')[0][0];
		var pathNode3 = d3.select(targetPath3).selectAll('path').node();
		var pathLength3 = pathNode3.getTotalLength();

		//append the circle to the first vertex of the geojson

		circle = group3.append("circle")
			.attr({
			r: 5,
			fill: '#00BFFF',
			transform: function () {
				var p = pathNode3.getPointAtLength(0)
				return "translate(" + [p.x, p.y] + ")";
			},
			id: lineNumber
		});

		// move the circle along the path
		duration = pathLength3/v;
		circle.transition()
			.duration(duration)
				.delay(750)
			.ease("linear")
			.attrTween("transform", function (d, i) {
			return function (t) {
				var p = pathNode3.getPointAtLength(pathLength3*t);
				return "translate(" + [p.x, p.y] + ")";
			}
		});

		//### Runde 4
		var group4 = svg.append("svg:g");
		
		//take the path from the geojson
		var targetPath4 = d3.selectAll('.route3')[0][0];
		var pathNode4 = d3.select(targetPath4).selectAll('path').node();
		var pathLength4 = pathNode4.getTotalLength();

		//append the circle to the first vertex of the geojson
		circle = group4.append("circle")
			.attr({
			r: 5,
			fill: '#00BFFF',
			transform: function () {
				var p = pathNode4.getPointAtLength(0)
				return "translate(" + [p.x, p.y] + ")";
			},
			id: lineNumber
		});

		// move the circle along the path
		duration = pathLength4/v;
		circle.transition()
			.duration(duration)
				.delay(750)
			.ease("linear")
			.attrTween("transform", function (d, i) {
			return function (t) {
				var p = pathNode4.getPointAtLength(pathLength4*t);
				return "translate(" + [p.x, p.y] + ")";
			}
		});

		//### Runde 5
		var group5 = svg.append("svg:g");
		
		//take the path from the geojson
		var targetPath5 = d3.selectAll('.route4')[0][0];
		var pathNode5 = d3.select(targetPath5).selectAll('path').node();
		var pathLength5 = pathNode5.getTotalLength();

		//append the circle to the first vertex of the geojson
		circle = group5.append("circle")
			.attr({
			r: 5,
			fill: '#00BFFF',
			transform: function () {
				var p = pathNode5.getPointAtLength(0)
				return "translate(" + [p.x, p.y] + ")";
			},
			id: lineNumber
		});

		// move the circle along the path
		duration = pathLength5/v;
		circle.transition()
			.duration(duration)
				.delay(750)
			.ease("linear")
			.attrTween("transform", function (d, i) {
			return function (t) {
				var p = pathNode5.getPointAtLength(pathLength5*t);
				return "translate(" + [p.x, p.y] + ")";
			}
		});
		
		//### Runde 6
		var group6 = svg.append("svg:g");
		
		//take the path from the geojson
		var targetPath6 = d3.selectAll('.route5')[0][0];
		var pathNode6 = d3.select(targetPath6).selectAll('path').node();
		var pathLength6 = pathNode6.getTotalLength();

		//append the circle to the first vertex of the geojson
		circle = group6.append("circle")
			.attr({
			r: 5,
			fill: '#00BFFF',
			transform: function () {
				var p = pathNode6.getPointAtLength(0)
				return "translate(" + [p.x, p.y] + ")";
			},
			id: lineNumber
		});

		// move the circle along the path
		duration = pathLength6/v;
		circle.transition()
			.duration(duration)
				.delay(750)
			.ease("linear")
			.attrTween("transform", function (d, i) {
			return function (t) {
				var p = pathNode6.getPointAtLength(pathLength6*t);
				return "translate(" + [p.x, p.y] + ")";
			}
		});
		
		//### Runde 7
		var group7 = svg.append("svg:g");
		
		//take the path from the geojson
		var targetPath7 = d3.selectAll('.route6')[0][0];
		var pathNode7 = d3.select(targetPath7).selectAll('path').node();
		var pathLength7 = pathNode7.getTotalLength();

		//append the circle to the first vertex of the geojson
		circle = group7.append("circle")
			.attr({
			r: 5,
			fill: '#00BFFF',
			transform: function () {
				var p = pathNode7.getPointAtLength(0)
				return "translate(" + [p.x, p.y] + ")";
			},
			id: lineNumber
		});

		// move the circle along the path
		duration = pathLength7/v;
		circle.transition()
			.duration(duration)
				.delay(750)
			.ease("linear")
			.attrTween("transform", function (d, i) {
			return function (t) {
				var p = pathNode7.getPointAtLength(pathLength7*t);
				return "translate(" + [p.x, p.y] + ")";
			}
		});
		
		//### Runde 8
		var group8 = svg.append("svg:g");
		
		//take the path from the geojson
		var targetPath8 = d3.selectAll('.route7')[0][0];
		var pathNode8 = d3.select(targetPath8).selectAll('path').node();
		var pathLength8 = pathNode8.getTotalLength();

		//append the circle to the first vertex of the geojson
		circle = group8.append("circle")
			.attr({
			r: 5,
			fill: '#00BFFF',
			transform: function () {
				var p = pathNode8.getPointAtLength(0)
				return "translate(" + [p.x, p.y] + ")";
			},
			id: lineNumber
		});

		// move the circle along the path
		duration = pathLength8/v;
		circle.transition()
			.duration(duration)
				.delay(750)
			.ease("linear")
			.attrTween("transform", function (d, i) {
			return function (t) {
				var p = pathNode8.getPointAtLength(pathLength8*t);
				return "translate(" + [p.x, p.y] + ")";
			}
		});
		
		//### Runde 9
		var group9 = svg.append("svg:g");
		
		//take the path from the geojson
		var targetPath9 = d3.selectAll('.route8')[0][0];
		var pathNode9 = d3.select(targetPath9).selectAll('path').node();
		var pathLength9 = pathNode9.getTotalLength();

		//append the circle to the first vertex of the geojson
		circle = group9.append("circle")
			.attr({
			r: 5,
			fill: '#00BFFF',
			transform: function () {
				var p = pathNode9.getPointAtLength(0)
				return "translate(" + [p.x, p.y] + ")";
			},
			id: lineNumber
		});

		// move the circle along the path
		duration = pathLength9/v;
		circle.transition()
			.duration(duration)
				.delay(750)
			.ease("linear")
			.attrTween("transform", function (d, i) {
			return function (t) {
				var p = pathNode9.getPointAtLength(pathLength9*t);
				return "translate(" + [p.x, p.y] + ")";
			}
		});
		
		//### Runde 10
		var group10 = svg.append("svg:g");
		
		//take the path from the geojson
		var targetPath10 = d3.selectAll('.route9')[0][0];
		var pathNode10 = d3.select(targetPath10).selectAll('path').node();
		var pathLength10 = pathNode10.getTotalLength();

		//append the circle to the first vertex of the geojson
		circle = group10.append("circle")
			.attr({
			r: 5,
			fill: '#00BFFF',
			transform: function () {
				var p = pathNode10.getPointAtLength(0)
				return "translate(" + [p.x, p.y] + ")";
			},
			id: lineNumber
		});

		// move the circle along the path
		duration = pathLength10/v;
		circle.transition()
			.duration(duration)
				.delay(750)
			.ease("linear")
			.attrTween("transform", function (d, i) {
			return function (t) {
				var p = pathNode10.getPointAtLength(pathLength10*t);
				return "translate(" + [p.x, p.y] + ")";
			}
		});

		lineNumber++;

	};
		
		</script>
  </body>
</html>